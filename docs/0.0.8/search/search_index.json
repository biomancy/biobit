{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The documentation is under construction.</p>"},{"location":"dev_notes/","title":"Architecture Decisions","text":""},{"location":"dev_notes/#io-primitives","title":"IO primitives","text":"<p>TODO: Explain encode-decode pattern.</p> <p>Read operations commonly accept mutable buffers to promote efficient reuse and minimize repeated allocations.</p>"},{"location":"dev_notes/#rust","title":"Rust","text":""},{"location":"dev_notes/#module-public-api-modrs","title":"Module Public API (<code>mod.rs</code>)","text":"<p>Each module's <code>mod.rs</code> file explicitly defines its public interface by re-exporting all intended public items (structs, enums, traits, functions, sub-modules) using <code>pub use</code>. This promotes clear discoverability (e.g., accessing <code>fasta::Record</code> requires importing the <code>fasta</code> module only) and establishes a stable contract for the module's users.</p>"},{"location":"dev_notes/#optional-prelude-preluders","title":"Optional Prelude (<code>prelude.rs</code>)","text":"<p>If a prelude module is used, its scope is strictly limited to re-exporting common traits anonymously (<code>pub use TraitName as _;</code>). This allows convenient access to trait extension methods via a single glob import (<code>use crate::prelude::*;</code>) without polluting the user's namespace with concrete type names, function names, or even trait names themselves, thereby encouraging explicit imports for types and enhancing code clarity. Adherence to this strict \u201ctraits-only, anonymous export\u201d rule is crucial for effectiveness.</p>"},{"location":"dev_notes/#traits-and-structures","title":"Traits And Structures","text":"<p>Core data types (e.g., <code>Interval</code>, <code>Record</code>) are defined as concrete structs. Functionality is defined by implementing fine-grained, behavior-oriented traits (e.g., <code>Spanning</code>, <code>Coverage</code>) directly on these structs. These traits define specific, composable capabilities.</p> <p>Common combinations of required traits are grouped using umbrella traits primarily to simplify trait bounds in generic Rust functions and types. These aliases must be named based on the collective capability they represent (e.g., <code>ProcessableRead</code>, <code>AlignableSequence</code>) to promote abstraction and flexibility, not based on structural similarity to a specific type (i.e., avoid names like <code>RecordLike</code> or <code>IntervalLike</code>).</p> <p>Python bindings are created by wrapping concrete Rust structs (e.g., <code>PyInterval</code> wrapping <code>Interval</code>) using <code>#[pyclass]</code>. These Python wrappers provide methods that mirror the functionality of the core behavioral traits implemented by the underlying Rust struct, offering a Pythonic interface to capabilities like <code>Spanning</code> or <code>Coverage</code>. This design also ensures that Python structs can be used in generic Rust functions, enabling easier interoperability between Rust and Python.</p> <p>For simplicity, all Rust traits have Python protocol equivalents that are leveraged for typing in Python bindings.</p>"},{"location":"dev_notes/#ownership-management-across-ffi-boundaries","title":"Ownership Management Across FFI Boundaries","text":"<p>Rust\u2019s ownership rules prevent returning borrowed references across FFI boundaries. When a function must reference input features (e.g., pairing read counts with the original records), those references need to remain valid in FFI for an indefinite period\u2014thus borrowing (<code>&amp;T</code>) is not feasible once data crosses the FFI boundary.</p> <p>We address this in two ways:</p> <ol> <li>Move Owned Inputs (<code>T</code>): If the function takes ownership of <code>T</code>, it can directly return that owned <code>T</code>. This is    the most efficient option, but not always feasible if an algorithm must produce multiple or iterative results.</li> <li>Create Owned Copies (<code>T</code>): An algorithm can produce multiple or iterative outputs for the same inputs by cloning    them internally. This requires <code>T: Clone</code>.</li> </ol> <p>The second option is used in some parts of the library. It does involve a performance penalty, but this can be mitigated by using smart pointers or partial copies in Rust. In return, it provides more flexible and FFI-friendly APIs.</p>"},{"location":"dev_notes/#python","title":"Python","text":""},{"location":"dev_notes/#send-and-sync-for-python-classes","title":"<code>Send</code> and <code>Sync</code> for Python Classes","text":"<p>With the introduction of free-threaded Python, the library assumes all Python objects can be safely shared and transferred between threads without explicit Python-side synchronization. Consequently, Python objects are treated as <code>Send</code> and <code>Sync</code>, an assumption generally enforced by PyO3.</p>"},{"location":"dev_notes/#why-not-implement-clone-or-copy-for-all-python-classes","title":"Why Not Implement <code>Clone</code> or <code>Copy</code> for All Python Classes?","text":"<p>This limitation is discussed in this PyO3 issue. Once resolved, suitable Python classes will implement <code>Clone</code> and/or <code>Copy</code> traits.</p>"},{"location":"dev_notes/#organizing-python-code-per-submodule-eg-modulespy","title":"Organizing Python Code per Submodule (e.g., <code>modules/*/py</code>)","text":"<p>Currently, dependencies among PyO3 modules are poorly supported (see this PyO3 issue). Specifically, common dependencies may compile multiple times, resulting in incompatible class versions. A temporary workaround involves creating and populating all <code>PyModule</code> instances within a single umbrella <code>lib.rs</code> file.</p> <p>Local Python dependencies also present challenges (see StackOverflow discussion). Presently, the workaround is to symlink sources for each module within an overarching Python project.</p>"},{"location":"dev_notes/#future-ideas","title":"Future Ideas","text":"<ul> <li>A long-term goal is to stimulate batch-oriented processing, particularly in Python wrappers.</li> </ul>"},{"location":"dev_notes/#the-bundle-trait","title":"The <code>Bundle</code> Trait","text":"<p>Logical grouping of structures (e.g., by strand or seqid) is frequently required. Initially, a dedicated <code>Bundle&lt;T&gt;</code> struct was considered but had several drawbacks:</p> <ul> <li>Primarily functioned as a thin wrapper around collections like <code>HashMap</code> or <code>BTreeMap</code>, adding minimal additional   functionality.</li> <li>Lacked clear responsibilities beyond basic data storage.</li> <li>Was inconvenient for Python users, requiring interaction with specialized Rust structures instead of familiar Python   types like <code>dict</code>.</li> </ul> <p>Instead of creating a standalone struct, a <code>Bundle</code> trait has been implemented across multiple collection types (<code>HashMap</code>, <code>BTreeMap</code>, <code>Vec</code>, etc.). This trait provides standardized methods (<code>get</code>, <code>remove</code>, <code>iter</code>) for uniform data access and integrates smoothly with Python wrappers through the dedicated <code>IntoBundle</code> struct, which can be constructed directly from Python types (<code>dict</code>, <code>list</code>, <code>tuple</code>).</p>"},{"location":"dev_notes/#struct-buffer-builder-triangle","title":"Struct-Buffer-Builder Triangle","text":"<p>In ideal circumstances, many library structures, especially those dealing with IO operations, should have three distinct states:</p> <ul> <li>Structure: Fully defined, meets all invariants.</li> <li>Buffer: A thread-safe, reference-erased memory buffer (<code>Send + Sync</code>) for efficient caching.</li> <li>Builder: Fully typed but partially initialized structures.</li> </ul> <p>These variants should be memory-compatible to enable zero-cost conversions between states via TransmuteFrom. Currently, <code>transmutability</code> is far from stabilization, and a proper implementation of this pattern is not possible.</p>"},{"location":"dev_notes/#rejected-ideas","title":"Rejected Ideas","text":""},{"location":"dev_notes/#stitching-of-inverted-repeats","title":"Stitching of Inverted Repeats","text":"<p>Idea: Introduce a <code>stitch(max_gap: usize)</code> method for inverted repeats, enabling merging of adjacent repeats separated by gaps smaller than <code>max_gap</code>.</p> <p>Reason: Impossible to implement without violating the underlying invariant. Stitching gaps will produce left/right sides of the inverted repeat that might not be of the same length.</p>"},{"location":"dev_notes/#data-field-for-fundamental-primitives","title":"Data field for fundamental primitives","text":"<p>Idea: Introduce a <code>data</code> field in fundamental structures (e.g., <code>Interval</code>) to store additional information. It could be generic with a default unit <code>()</code> type.</p> <p>Reason: This would complicate the design and usage of these structures. For example, what should happen when merging two <code>Interval</code> objects with different <code>data</code> types? Should the <code>data</code> field be merged or discarded? In the face of such ambiguities, it is better to avoid the <code>data</code> field altogether.</p>"}]}