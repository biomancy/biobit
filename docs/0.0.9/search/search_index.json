{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The documentation is under construction.</p>"},{"location":"arrow/","title":"Apache Arrow","text":""},{"location":"arrow/#a-draft-design-document","title":"A draft design document.","text":"<p>The library has adopted Apache Arrow as its primary in-memory format for batch data processing. This decision enables zero-copy data sharing between the high-performance Rust core and language bindings like Python. Most data structures are implemented as columnar batches, where each record field is represented as a single column (a structure-of-arrays, or SoA).</p>"},{"location":"arrow/#api-design-the-two-type-system","title":"API Design: The Two-Type System","text":"<p>To ensure safety and clarity, the API is built on a two-type system that separates immutable and mutable states. Functionality is scoped within modules (e.g., <code>module::Batch</code>).</p> <ul> <li><code>module::Batch</code>: The default, immutable, and shareable type. It's designed for all read-only operations and   queries. It is cheap to clone, as it only increments reference counts to the underlying data.</li> <li><code>module::BatchMut</code>: A unique, owning, and mutable type. This type provides methods for efficient, in-place   data modification with guaranteed exclusive access.</li> </ul> <p>The conversion between types is framed as an explicit \"editing session,\" ensuring user intent is clear across both the Rust and Python APIs.</p> <ul> <li><code>.edit()</code>: Converts an immutable <code>Batch</code> into a mutable <code>BatchMut</code>. This is a safe operation that uses a *   Copy-on-Write (CoW)* mechanism at the column level. A copy is only performed for columns that are actually mutated,   and only when they are first modified.</li> <li><code>.commit()</code>: Finalizes the editing session by consuming the <code>BatchMut</code> and returning a new, immutable <code>Batch</code>.   This is a zero-cost operation.</li> </ul> <p>The design avoids interior mutability; <code>BatchMut</code> enforces exclusive ownership via Rust's standard ownership model. Language bindings enforce this by wrapping <code>BatchMut</code> instances in a <code>Mutex</code> to serialize access and ensure thread safety.</p> <p>Importantly, it's rarely possible to leverage CoW mechanism in bindings, because they don't destroy the original <code>Batch</code> when calling <code>.edit()</code> thus leading to a shared ownership between CoW buffers in the <code>BatchMut</code> and the original <code>Batch</code>. Or, even more often, the bindings will cache references to FFI-exposed buffers addressed at least once, which also leads to shared ownership. This means that any mutation will always trigger a copy, leading to suboptimal performance. See the [[Unsafe In-Place Mutation]] section for an escape hatch.</p>"},{"location":"arrow/#unsafe-in-place-mutation","title":"Unsafe In-Place Mutation","text":"<p>For performance-critical paths, an escape hatch is provided to bypass the CoW mechanism and mutate data in place.</p> <ul> <li>Rust: <code>unsafe fn edit_inplace(self) -&gt; BatchMut</code></li> <li>Python: <code>unsafe_edit_inplace(self) -&gt; BatchMut</code></li> </ul> <p>Calling these functions is a promise that the user holds unique references to all <code>Batch</code> columns. If this contract is violated, other references will observe the mutated data, leading to a data race.</p>"},{"location":"arrow/#extension-trait-architecture","title":"Extension Trait Architecture","text":"<p>Functionality is delivered via a layered extension trait architecture. This allows <code>batch.method()</code> to work seamlessly, mimicking the ergonomic APIs of libraries like PyTorch or Pandas.</p> <ul> <li><code>core::BatchExt</code>: A generic trait for universal, read-only operations (e.g., <code>len()</code>, <code>slice()</code>).</li> <li><code>core::BatchMutExt</code>: A generic trait for universal, in-place mutating operations (e.g., <code>shrink_to_fit()</code>).</li> <li><code>module::BatchExt</code>: A specific trait for module-related, read-only operations. It is implemented for both   <code>module::Batch</code> and <code>module::BatchMut</code>.</li> <li><code>module::BatchMutExt</code>: A specific trait for module-related, in-place mutating operations, implemented only for   <code>module::BatchMut</code>.</li> </ul>"},{"location":"dev-guide/","title":"Developer Guide","text":""},{"location":"dev-guide/#project-structure","title":"Project Structure","text":"<p>The <code>biobit</code> project is organized as a Cargo workspace with several member crates, facilitating modular development and clear separation of concerns:</p> <ul> <li><code>biobit/py</code>: This is the primary Python package crate. It acts as an umbrella, integrating all Rust modules and   exposing them as a unified Python package named <code>biobit</code>.<ul> <li>Its <code>src/bindings.rs</code> is the central FFI definition point. It constructs the main Python extension module (   imported as <code>biobit.rs</code> in Python) and attaches all other Rust-backed submodules (e.g., <code>biobit.rs.core</code>,   <code>biobit.rs.io</code>). This centralized approach is adopted to manage   dependencies between PyO3 modules effectively (see <code>dev_notes.md</code> for background on PyO3 module dependency   challenges).</li> </ul> </li> <li><code>modules/</code>: This directory houses the core Rust logic and their corresponding Python bindings. It is divided into:<ul> <li>Functional Modules: These provide fundamental bioinformatics capabilities (e.g., <code>core</code>, <code>io</code>, <code>alignment</code>,   <code>collections</code>).</li> <li>Toolkit Modules: These offer higher-level tools and pipelines (e.g., <code>countit</code>, <code>reaper</code>, <code>repeto</code>).</li> <li>Each module under <code>modules/</code> (whether functional or toolkit) typically follows a consistent structure:<ul> <li><code>rs/</code>: Contains the pure Rust implementation of the module's logic (e.g., <code>modules/core/rs/</code>). This crate   focuses on performance and Rust-idiomatic APIs.</li> <li><code>py/</code>: Contains the PyO3 bindings for the corresponding <code>rs</code> crate (e.g., <code>modules/core/py/</code>). This crate   is responsible for exposing Rust functionality to Python in a user-friendly way and links against the <code>rs</code>   crate of the same module.</li> </ul> </li> </ul> </li> <li><code>resources/</code>: This top-level directory contains test files, example data, and other static assets. See   the Resource Management section below for details.</li> </ul> <p>The overall workspace structure is defined in the main <code>biobit/Cargo.toml</code> file.</p>"},{"location":"dev-guide/#resource-management","title":"Resource Management","text":"<p>Only static resources shared between modules are hosted in the top-level <code>resources/</code> directory to ensure easy access and consistent organization. All data used exclusively by tests and benchmarks in individual modules is stored in the corresponding per-module <code>module/resources</code> folder, which links to required shared files from the top-level <code>resources/</code>. This approach avoids duplication while maintaining module-specific data separation.</p>"},{"location":"dev-guide/#resources-inventory","title":"Resources Inventory","text":"<p>A comprehensive inventory and description of all data files within the top-level and per-module <code>resources/</code> folders must be maintained in linked <code>README.md</code> files. This documentation serves as the definitive guide to understanding the purpose, origin, and structure of each resource, ensuring they are discoverable and well-understood.</p>"},{"location":"dev-guide/#accessing-resources-in-tests","title":"Accessing Resources in Tests","text":"<p>The top-level resources folder is defined via an environment variable in the project configuration, allowing tests from all languages to access the same resources without hardcoding paths:</p> <ul> <li>Rust: <code>env!(\"BIOBIT_RESOURCES\")</code></li> <li>Python: <code>os.environ['BIOBIT_RESOURCES']</code></li> </ul> <p>TODO: Add a note on how to access per-module resources in tests.</p>"},{"location":"notes/","title":"Architecture Decisions","text":""},{"location":"notes/#io-primitives","title":"IO primitives","text":"<p>TODO: Explain encode-decode pattern.</p> <p>Read operations commonly accept mutable buffers to promote efficient reuse and minimize repeated allocations.</p>"},{"location":"notes/#rust","title":"Rust","text":""},{"location":"notes/#module-public-api-modrs","title":"Module Public API (<code>mod.rs</code>)","text":"<p>Each module's <code>mod.rs</code> file explicitly defines its public interface by re-exporting all intended public items (structs, enums, traits, functions, sub-modules) using <code>pub use</code>. This promotes clear discoverability (e.g., accessing <code>fasta::Record</code> requires importing the <code>fasta</code> module only) and establishes a stable contract for the module's users.</p>"},{"location":"notes/#optional-prelude-preluders","title":"Optional Prelude (<code>prelude.rs</code>)","text":"<p>If a prelude module is used, its scope is strictly limited to re-exporting common traits anonymously (<code>pub use TraitName as _;</code>). This allows convenient access to trait extension methods via a single glob import (<code>use crate::prelude::*;</code>) without polluting the user's namespace with concrete type names, function names, or even trait names themselves, thereby encouraging explicit imports for types and enhancing code clarity. Adherence to this strict \u201ctraits-only, anonymous export\u201d rule is crucial for effectiveness.</p>"},{"location":"notes/#traits-and-structures","title":"Traits And Structures","text":"<p>Core data types (e.g., <code>Interval</code>, <code>Record</code>) are defined as concrete structs. Functionality is defined by implementing fine-grained, behavior-oriented traits (e.g., <code>Spanning</code>, <code>Coverage</code>) directly on these structs. These traits define specific, composable capabilities.</p> <p>Common combinations of required traits are grouped using umbrella traits primarily to simplify trait bounds in generic Rust functions and types. These aliases must be named based on the collective capability they represent (e.g., <code>ProcessableRead</code>, <code>AlignableSequence</code>) to promote abstraction and flexibility, not based on structural similarity to a specific type (i.e., avoid names like <code>RecordLike</code> or <code>IntervalLike</code>).</p> <p>Python bindings are created by wrapping concrete Rust structs (e.g., <code>PyInterval</code> wrapping <code>Interval</code>) using <code>#[pyclass]</code>. These Python wrappers provide methods that mirror the functionality of the core behavioral traits implemented by the underlying Rust struct, offering a Pythonic interface to capabilities like <code>Spanning</code> or <code>Coverage</code>. This design also ensures that Python structs can be used in generic Rust functions, enabling easier interoperability between Rust and Python.</p> <p>For simplicity, all Rust traits have Python protocol equivalents that are leveraged for typing in Python bindings.</p>"},{"location":"notes/#ownership-management-across-ffi-boundaries","title":"Ownership Management Across FFI Boundaries","text":"<p>Rust\u2019s ownership rules prevent returning borrowed references across FFI boundaries. When a function must reference input features (e.g., pairing read counts with the original records), those references need to remain valid in FFI for an indefinite period\u2014thus borrowing (<code>&amp;T</code>) is not feasible once data crosses the FFI boundary.</p> <p>We address this in two ways:</p> <ol> <li>Move Owned Inputs (<code>T</code>): If the function takes ownership of <code>T</code>, it can directly return that owned <code>T</code>. This is    the most efficient option, but not always feasible if an algorithm must produce multiple or iterative results.</li> <li>Create Owned Copies (<code>T</code>): An algorithm can produce multiple or iterative outputs for the same inputs by cloning    them internally. This requires <code>T: Clone</code>.</li> </ol> <p>The second option is used in some parts of the library. It does involve a performance penalty, but this can be mitigated by using smart pointers or partial copies in Rust. In return, it provides more flexible and FFI-friendly APIs.</p>"},{"location":"notes/#python","title":"Python","text":""},{"location":"notes/#send-and-sync-for-python-classes","title":"<code>Send</code> and <code>Sync</code> for Python Classes","text":"<p>With the introduction of free-threaded Python, the library assumes all Python objects can be safely shared and transferred between threads without explicit Python-side synchronization. Consequently, Python objects are treated as <code>Send</code> and <code>Sync</code>, an assumption generally enforced by PyO3.</p>"},{"location":"notes/#why-not-implement-clone-or-copy-for-all-python-classes","title":"Why Not Implement <code>Clone</code> or <code>Copy</code> for All Python Classes?","text":"<p>This limitation is discussed in this PyO3 issue. Once resolved, suitable Python classes will implement <code>Clone</code> and/or <code>Copy</code> traits.</p>"},{"location":"notes/#organizing-python-code-per-submodule-eg-modulespy","title":"Organizing Python Code per Submodule (e.g., <code>modules/*/py</code>)","text":"<p>Currently, dependencies among PyO3 modules are poorly supported (see this PyO3 issue). Specifically, common dependencies may compile multiple times, resulting in incompatible class versions. A temporary workaround involves creating and populating all <code>PyModule</code> instances within a single umbrella <code>lib.rs</code> file.</p> <p>Local Python dependencies also present challenges (see StackOverflow discussion). Presently, the workaround is to symlink sources for each module within an overarching Python project.</p>"},{"location":"notes/#future-ideas","title":"Future Ideas","text":"<ul> <li>A long-term goal is to stimulate batch-oriented processing, particularly in Python wrappers.</li> </ul>"},{"location":"notes/#the-bundle-trait","title":"The <code>Bundle</code> Trait","text":"<p>Logical grouping of structures (e.g., by strand or seqid) is frequently required. Initially, a dedicated <code>Bundle&lt;T&gt;</code> struct was considered but had several drawbacks:</p> <ul> <li>Primarily functioned as a thin wrapper around collections like <code>HashMap</code> or <code>BTreeMap</code>, adding minimal additional   functionality.</li> <li>Lacked clear responsibilities beyond basic data storage.</li> <li>Was inconvenient for Python users, requiring interaction with specialized Rust structures instead of familiar Python   types like <code>dict</code>.</li> </ul> <p>Instead of creating a standalone struct, a <code>Bundle</code> trait has been implemented across multiple collection types (<code>HashMap</code>, <code>BTreeMap</code>, <code>Vec</code>, etc.). This trait provides standardized methods (<code>get</code>, <code>remove</code>, <code>iter</code>) for uniform data access and integrates smoothly with Python wrappers through the dedicated <code>IntoBundle</code> struct, which can be constructed directly from Python types (<code>dict</code>, <code>list</code>, <code>tuple</code>).</p>"},{"location":"notes/#struct-buffer-builder-triangle","title":"Struct-Buffer-Builder Triangle","text":"<p>In ideal circumstances, many library structures, especially those dealing with IO operations, should have three distinct states:</p> <ul> <li>Structure: Fully defined, meets all invariants.</li> <li>Buffer: A thread-safe, reference-erased memory buffer (<code>Send + Sync</code>) for efficient caching.</li> <li>Builder: Fully typed but partially initialized structures.</li> </ul> <p>These variants should be memory-compatible to enable zero-cost conversions between states via TransmuteFrom. Currently, <code>transmutability</code> is far from stabilization, and a proper implementation of this pattern is not possible.</p>"},{"location":"notes/#rejected-ideas","title":"Rejected Ideas","text":""},{"location":"notes/#stitching-of-inverted-repeats","title":"Stitching of Inverted Repeats","text":"<p>Idea: Introduce a <code>stitch(max_gap: usize)</code> method for inverted repeats, enabling merging of adjacent repeats separated by gaps smaller than <code>max_gap</code>.</p> <p>Reason: Impossible to implement without violating the underlying invariant. Stitching gaps will produce left/right sides of the inverted repeat that might not be of the same length.</p>"},{"location":"notes/#data-field-for-fundamental-primitives","title":"Data field for fundamental primitives","text":"<p>Idea: Introduce a <code>data</code> field in fundamental structures (e.g., <code>Interval</code>) to store additional information. It could be generic with a default unit <code>()</code> type.</p> <p>Reason: This would complicate the design and usage of these structures. For example, what should happen when merging two <code>Interval</code> objects with different <code>data</code> types? Should the <code>data</code> field be merged or discarded? In the face of such ambiguities, it is better to avoid the <code>data</code> field altogether.</p>"}]}